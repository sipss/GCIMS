---
title: "Introduction to GCIMS"
output: BiocStyle::html_document
package: GCIMS
author: "GCIMS authors"
date: "`r format(Sys.Date(), '%F')`"
abstract: >
  An introduction to the GCIMS package, showing the most relevant functions and
  a proposed workflow. This includes loading demo samples, adding sample
  annotations, preprocessing the spectra, alignment, detecting peaks and regions
  of interest (ROIs), clustering of ROIs across samples, peak integration and
  building a peak table.
vignette: >
  %\VignetteIndexEntry{Introduction to GCIMS}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(ggplot2)
library(GCIMS)
```

The GCIMS package allows you to import your Gas Chromatography - Ion Mobility Spectrometry samples,
preprocess them, align them one to each other and build a peak table with the relevant features.

This vignette will use a small dataset consisting of a mixture of three ketones.

## Downloading the dataset:

```{r}
# Download the ketones dataset:
tryCatch({
  download_three_ketones_dataset("threeketones")
}, error = function(e) {
  message("The download of the samples did not succeed. The vignette can't continue.")
  message(conditionMessage(e))
  knitr::knit_exit()
})
```

```{r}
# Check that the files are downloaded:
list.files("threeketones")
```

Enable parallellization of the workflow, here we use three cores:

```{r}
library(BiocParallel)
#register(SerialParam(progressbar = TRUE), default = TRUE)  # disable parallellization
register(SnowParam(workers = 3, progressbar = TRUE), default = TRUE)  # enable parallellization with 3 workers
```


## Create work directories

The first steps, is to create all the directories and folders where the samples are located and will be stored along all the process. 
The current working directory should be the folder where the raw data samples are located. Folders for each pre-processing step will be 
created.

```{r}
wd <- "intermediate_files"
data <- file.path(wd,'data')
reshaped <- file.path(wd,'reshaped')
cut <- file.path(wd,'cut')
prepared <- file.path(wd,'prepared')
aligned <- file.path(wd,'aligned')
roispp <- file.path(wd,'roispp')
bsln <- file.path(wd, 'bsln')
fom <- file.path(wd, 'fom')
```

## Import data

Please start by preparing an Excel spreadsheet (or a CSV/TSV file if you prefer)
with your samples and their annotations. Please name the first column `SampleID`
and the second column `Filename`.

```{r}
## We will directly define the data frame here:

sample_annotations <- tibble::tribble(
  ~SampleID, ~Filename,
  "Ketone1", "211105_095453.mea.gz",
  "Ketone2", "211105_135744.mea.gz",
  "Ketone3", "211108_141524.mea.gz",
)
## But you can use the following code:
## Use this for excel spreadsheets:
# sample_annotations <- readxl::read_excel("your_excel_file.xlsx")
## Use this for CSV files:
# sample_annotations <- readr::read_csv("your_csv_file.csv")

sample_annotations
```

Raw data:

- Reading samples: gcims_read_samples
All the samples for the working directory are going to be read and convert into the format needed for working with this package

```{r}
# READING SAMPLES
# For mea or mea.gz files, use:
dataset <- gcims_read_mea(dir_in = "threeketones", dir_out = data)
```

- Reading metadata: gcims_read_metadata
An excel file containing all the metadata information needed is going to be read and all the metadata information will be included 
in the files

```{r}
# READING METADATA
samples <- seq_along(dataset)
#file <- "Metadata.xlsx"
file <- data.frame(
  Name = c(1,2,3),
  OriginalFileName = names(dataset)
)
gcims_read_metadata(dir_in = data, samples, file)
```

- Cut samples: gcims_cut_samples
The samples are cut for a better data manipulation. There are part of the data matrix that does not contain any information.
The sample cut can be performed at the beginning, but also at the end after all the pre-processing.

```{r}
gcims_cut_samples(
  dir_in = data,
  dir_out = cut,
  samples = 1:3,
  rt_range = c(1, 1300), # in seconds 
  dt_range = c(7, 17) # in ms
)
```

- Reshape sample: reshape_samples
An adjustment of the dimensions of the samples is performed. There are occasions where the samples do not measure exactly the same,
making very complicated working with them.

```{r}
# RESHAPE SAMPLES
gcims_reshape_samples(dir_in = cut, dir_out = reshaped, samples)
```

- Prepare samples: gcims_prepare_data
It does some pre-processing steps such as interpolation, digital filter and decimation.The parameters needed for each function should be indicated by the user.

```{r}
#PREPARE DATA
alignment_data <- gcims_prepare_data(
  dir_in = reshaped,
  dir_out = prepared,
  samples = 1:3,
  params = list(
    filter = list(
      do = TRUE,
      order_rt = 2,
      length_rt = 19,
      order_dt = 2,
      length_dt = 19
    ),
    decimate = list(
      do = TRUE,
      factor_rt = 2,
      factor_dt = 2
    )
  )
)
```

- Align data: gcims_align_data
Data is aligned in drift and retention time axes. 

```{r}
# ALIGN SAMPLES
aligment_info <- gcims_align_data(
  dir_in = prepared, 
  dir_out = aligned,
  samples = 1:3,
  alignment_data = alignment_data)

```


- Data Visualization
Useful to understand data and changes in data due to the pre-processing stage. You can visualize the whole gcims data from a sample using 'gcims_view_sample()'; a particular spectrum for different samples using 'gcims_plot_spec()'; or a particular chromatogram for different samples using 'gcims_plot_chrom()'. We will use this functions to show the data before and after sample alignment.

Let's start showing the global effects in sample 1:
```{r}
# VISUALIZE THE EFFECT OF ALIGNMENT (IMAGE)
gcims_view_sample(prepared, sample_num = 1, rt_range = NULL, dt_range = NULL, transform = TRUE)
gcims_view_sample(aligned, sample_num = 1, rt_range = NULL, dt_range = NULL, transform = TRUE)
```

Note tha sample 1, was essentially unchanged.
Then, we will compare the Total Ion Spectra (TISs) of all samples:
```{r}
# VISUALIZE THE EFFECT OF ALIGNMENT (TOTAL ION SPECTRUM)
gcims_plot_spec(prepared, samples = 1:3, rt_value = NULL, dt_range = c(7.2,10), colorby = "Name")
gcims_plot_spec(aligned, samples = 1:3, rt_value =NULL, dt_range = c(7.2,10), colorby = "Name")

```

In this case, is evident that sample 3 needed to be aligned properly and that the job was properly done by the function 'gcims_align_data()'.
Finally, we do the same, but showing the Total Ion Chromatogram (TICs) of all samples.
```{r}
# VISUALIZE THE EFFECT OF ALIGNMENT (TOTAL ION CHROMATOGRAM)
gcims_plot_chrom(prepared, samples = 1:3, dt_value =NULL , rt_range =  NULL, colorby = "Name")
gcims_plot_chrom(aligned, samples = 1:3, dt_value =NULL , rt_range =  NULL, colorby = "Name")
```
The resulting TICs become aligned, as expected. 


- ROIs detection: gcims_rois_selection


```{r}
# ROIs DETECTION
peak_list <- gcims_rois_selection(dir_in = aligned, dir_out = roispp, samples = 1:3, noise_level = 3)
head(peak_list)

ggplot() +
  geom_rect(
    data = peak_list,
    mapping = aes(
      xmin = dt_min_ms, xmax = dt_max_ms, ymin = rt_min_s, ymax = rt_max_s,
      color = SampleID,
      fill = SampleID
    ),
    alpha = 0.5
  )
```

```{r}
peak_clustering <- group_peak_list(peak_list, distance_method = "sd_scaled_euclidean", clustering = list(method = "kmedoids", Nclusters = 13))
```

```{r}
peak_list_clustered <- peak_clustering$peak_list_clustered
```

- ROIs Fusion: gcims_rois_fusion

```{r}
#ROIs Fusion
tt <- gcims_rois_fusion(peak_clustering)
samplestocheck <- dplyr::filter(tt$peak_list_clustered, cluster == 7)
ggplot() +
  geom_rect(
    data = samplestocheck,
    mapping = aes(
      xmin=dt_min_ms,
      xmax=dt_max_ms,
      ymin=rt_min_s,
      ymax=rt_max_s,
      fill = SampleID,
      color = SampleID
    ),
    alpha=0.5
  ) +
  labs(x = "Drift time (ms)", "Retention time (s)")
```

- Baseline Correction: gcims_remove_baseline

```{r}
gcims_remove_baseline(
  dir_in = roispp,
  dir_out = bsln,
  samples = 1:3,
  peak_list_clustered
)
```

- Figures of Merit: gcims_figures_of_merit
Calculation of the figures of merit: area, volume, asymmetry and saturation.
It creates a ".csv" file with all the ROIs information 

```{r}
peak_list_foms <- gcims_figures_of_merit(dir_in = bsln, dir_out = fom, samples = (1:3), peak_list = tt$peak_list_clustered)
head(peak_list_foms)
```

- Build Peak Table: build_peak_table

```{r}
peak_table <- build_peak_table(peak_list_foms, aggregate_conflicting_peaks = max)
peak_table_with_na <- peak_table$peak_table
```

- Imput Missing Values: gcims_missing_imputation
Imputation of the missing values found in the peak table. 
It calculates the volume in the region of the reference ROI for each cluster for 
each sample having a missing value for the cluster.
```{r}
peak_table_imputed <- gcims_missing_imputation(dir_in = bsln, peak_table_with_na, peak_list_foms)
head(peak_table_imputed)
```


# Session Info:

```{r}
sessionInfo()
```

