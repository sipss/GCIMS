---
title: "Introduction to GCIMS"
output: BiocStyle::html_document
package: GCIMS
author: "GCIMS authors"
date: "`r format(Sys.Date(), '%F')`"
abstract: >
  An introduction to the GCIMS package, showing the most relevant functions and
  a proposed workflow. This includes loading demo samples, adding sample
  annotations, preprocessing the spectra, alignment, detecting peaks and regions
  of interest (ROIs), clustering of ROIs across samples, peak integration and
  building a peak table.
vignette: >
  %\VignetteIndexEntry{Introduction to GCIMS}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(ggplot2)
library(GCIMS)
```

The GCIMS package allows you to import your Gas Chromatography - Ion Mobility Spectrometry samples,
preprocess them and build a peak table of their relevant features.

This vignette will use a small dataset consisting of a mixture of three ketones.

# Downloading the dataset

Download the "threeketones" dataset:

```{r}
tryCatch({
  download_three_ketones_dataset("threeketones")
}, error = function(e) {
  message("The download of the samples did not succeed. The vignette can't continue.")
  message(conditionMessage(e))
  knitr::knit_exit()
})
```
Check that the files are downloaded:

```{r}
list.files("threeketones")
```

Enable parallellization of the workflow, here we use three cores:

```{r}
library(BiocParallel)
#register(SerialParam(progressbar = TRUE, exportglobals = FALSE), default = TRUE)  # disable parallellization
register(SnowParam(workers = 3, progressbar = TRUE, exportglobals = FALSE), default = TRUE)  # enable parallellization with 3 workers
```


# Create working directories

The first step is to create all directories and folders where samples will be stored. The current working directory should be the folder where the raw data samples are located. Folders for each pre-processing step will be created.

```{r}
wd <- "intermediate_files"
data <- file.path(wd,'data')
reshaped <- file.path(wd,'reshaped')
cut <- file.path(wd,'cut')
prepared <- file.path(wd,'prepared')
aligned <- file.path(wd,'aligned')
roispp <- file.path(wd,'roispp')
bsln <- file.path(wd, 'bsln')
fom <- file.path(wd, 'fom')
```

# Import data

Please, start by preparing an Excel spreadsheet (or a CSV/TSV file if you prefer)
with your samples and their annotations. Please name the first column `SampleID`
and the second column `Filename`.

```{r}
## We will directly define the data frame here:

sample_annotations <- tibble::tribble(
  ~SampleID, ~Filename,
  "Ketone1", "211105_095453.mea.gz",
  "Ketone2", "211105_135744.mea.gz",
  "Ketone3", "211108_141524.mea.gz",
)
## But you can use the following code:
## Use this for excel spreadsheets:
# sample_annotations <- readxl::read_excel("your_excel_file.xlsx")
## Use this for CSV files:
# sample_annotations <- readr::read_csv("your_csv_file.csv")

sample_annotations
```

- Reading raw data 

All samples of the working directory are going to be read and converted to the format needed for working with this package.

```{r}
# For mea or mea.gz files, use:
dataset <- gcims_read_mea(dir_in = "threeketones", dir_out = data)
```

- Reading metadata 

An excel file containing sample metadata is going to be read and all the metadata information will be included  in the files.

```{r}
samples <- seq_along(dataset)
#file <- "Metadata.xlsx"
file <- data.frame(
  Name = c(1,2,3),
  OriginalFileName = names(dataset)
)
gcims_read_metadata(dir_in = data, samples, file)
```

# Data Visualization

Visualize data is useful to understand data. The package provides three main data visualization functions to perform this task: `gcims_view_sample()`, `gcims_plot_spec()`, and `gcims_plot_chrom()`. By the moment, we will use the function `gcims_view_sample()` to inspect one sample. 

```{r}
gcims_view_sample(data, 
                  sample_num = 1,
                  rt_range = NULL, 
                  dt_range = NULL, transform = TRUE)
```

# Reducing sample size

Data samples are cut for a better manipulation. The package provides two different function two perform this task: `gcims_cut_samples()` and `gcims_reshape_samples()`.

- Cut samples

The function `gcims_cut_samples()` cuts all samples in a retention time - drift time rectangle selected by the user. The sample cut can be performed at the beginning, but also at the end after all the pre-processing.

```{r}
gcims_cut_samples(dir_in = data,
                  dir_out = cut,
                  samples = 1:3,
                  rt_range = c(1, 1300), # in seconds 
                  dt_range = c(7, 17) # in ms
)
```

Let's visualize sample 1 after cutting it:
```{r}
gcims_view_sample(cut, 
                  sample_num = 1, 
                  rt_range = NULL, 
                  dt_range = NULL, 
                  transform = TRUE)
```

- Reshape samples

There are occasions where all samples in a dataset do not have the same size. When this happens, an adjustment of the dimensions of samples is performed using `gcims_reshape_samples()`. Take into account that `gcims_cut_samples()` and `gcims_reshape_samples()` perform similar tasks. It can be the case that after cutting all samples (like in this examples) no further reshape is needed. Though, we include the reshape stage of data pre-processing workflow to exemplify how the function `gcims_reshape_samples()` works:

```{r}
gcims_reshape_samples(dir_in = cut,
                      dir_out = reshaped,
                      samples)
```

# Pre-processing

GCIMS data usually suffers from noise, drift and retention time axes misalignment.  Data pre-processing corrects this non-idealities of data. Use the functions `gcims_prepare_data()`ans `gcims_align_data()` to solve these problems, respectively.

- Prepare samples

The function  `gcims_prepare_data()` performs the first set of data pre-processing steps: interpolation, digital filtering (Savitzky-Golay filters), and decimation, both in drift and retention time axes. The parameters needed for each function should be indicated by the user.

```{r}
alignment_data <- gcims_prepare_data(
  dir_in = reshaped,
  dir_out = prepared,
  samples = 1:3,
  params = list(
    filter = list(
      do = TRUE,
      order_rt = 2,
      length_rt = 19,
      order_dt = 2,
      length_dt = 19
    ),
    decimate = list(
      do = TRUE,
      factor_rt = 2,
      factor_dt = 2
    )
  )
)
```

The plot for samples' spectra at retention time rt_value = 90 s, after preparing data is:
```{r}
gcims_plot_spec(prepared,
                samples = 1:3, 
                rt_value = 90, 
                dt_range = c(7.2,10),
                colorby = "Name")
```

Similarly, the chromatoagrams of all samples at drift time dt_value = 11.1 ms is:
```{r}
gcims_plot_chrom(prepared, 
                 samples = 1:3,
                 dt_value = 11.1,
                 rt_range =  NULL, 
                 colorby = "Name")
```

- Align data

Data is aligned in drift and retention time axes applying the function `gcims_alingn_data()`. The correction in drift time axis is multiplicative, that is, a multiplicative correction factor is computed for each of the samples so that the position of the Reactant Ion Peak (RIP) in spectra is the same across samples. The correction in retention time axis is achieved using the Parametric Time Warping (PTW) algorithm. 

```{r}
alignment_info <- gcims_align_data(
  dir_in = prepared, 
  dir_out = aligned,
  samples = 1:3,
  alignment_data = alignment_data)
```


Let's show gcims after sample alignment. Compare the spectra of all samples at retention time rt_value = 90 s, before and after the alignment:
```{r}
gcims_plot_spec(aligned,
                samples = 1:3,
                rt_value = 90, 
                dt_range = c(7.2,10), 
                colorby = "Name")
```

In this case, is evident that sample 3 needed to be aligned and that the job was properly done by the function 'gcims_align_data()'.
We can do the same for the chromatograms of all samples at drift time dt_value = 11.1 ms:
```{r}
gcims_plot_chrom(aligned, 
                 samples = 1:3,
                 dt_value = 11.1, 
                 rt_range =  NULL, 
                 colorby = "Name")
```
The resulting chromatograms become aligned, as expected. After this pre-processing stage, regions with peaks in data will be detected. Since several peaks may be convoluted in these regions we will call them Regions Of Interest, or ROI for short.


# Feature Extraction

Chemical information is GCIMS data is found in peaks. To characterize a sample, one must detect all their present peaks. Also, one must know the correspondence of these peaks across samples. These two tasks are carried out by the functions 'gcims_rois_selection()' and 'group_peak_list()', respectively. 

- ROI detection

The following piece of code shows how to detect all ROI in a dataset. Also, it shows in an image where these ROI are located in data. Each rectangle corresponds to a different ROI. ROI are colored by sample.

```{r}
peak_list <- gcims_rois_selection(dir_in = aligned,
                                  dir_out = roispp, 
                                  samples = 1:3,
                                  noise_level = 3)
head(peak_list)

ggplot() +
  geom_rect(
    data = peak_list,
    mapping = aes(
      xmin = dt_min_ms, xmax = dt_max_ms, ymin = rt_min_s, ymax = rt_max_s,
      color = SampleID,
      fill = SampleID
    ),
    alpha = 0.5
  )
```
You can see that some ROI are common across samples, while other not.


- ROI clustering

We clustered the ROI of dataset using the kmedoids method and the scaled Euclidean distance. Please consult the documentation of function
'group_peak_list()' to select other methods and distances. At the end of this process, an R object is obtained (a list):

```{r}
peak_clustering <- group_peak_list(peak_list, 
                                   distance_method = "sd_scaled_euclidean", 
                                   clustering = list(method = "kmedoids", Nclusters = 13))
```

From this list you can extract a peak list:

```{r}
peak_list_clustered <- peak_clustering$peak_list_clustered
```

Also, some statistics of the clustering:

```{r}
peak_clustering$cluster_stats
```

- Baseline Correction

Each ROI is characterized by its volume and other figures of merit. To calculate properly the volume, one must first subtract the baseline of data, in both drift and retention time axes. This is done by the function `gcims_remove_baseline()`.
```{r}
gcims_remove_baseline(
  dir_in = roispp,
  dir_out = bsln,
  samples = 1:3,
  peak_list_clustered
)
```

- Effect of Baseline removal

The following plots show the images of sample 1, before and after baseline correction. A side effect of this correction is the destruction of Reactant Ion Peack Chromatogram along retention time axis.
```{r}
gcims_view_sample(cut,
                  sample_num = 1,
                  rt_range = NULL, 
                  dt_range = NULL, 
                  transform = TRUE)
gcims_view_sample(bsln,
                  sample_num = 1,
                  rt_range = NULL, 
                  dt_range = NULL, 
                  transform = TRUE)
```
- ROI Fusion

It may happen that ROI belonging to the same cluster are detected more than once in the same sample. The function `gcims_rois_fusion()` fuses the repeated ROI into one.

```{r}
fusion_res <- gcims_rois_fusion(
  peak_clustering$peak_list_clustered,
  peak_clustering$cluster_stats
)

ggplot() +
  geom_rect(
    data = dplyr::filter(fusion_res$peak_list_clustered, cluster == "Cluster07"),
    mapping = aes(
      xmin=ref_roi_dt_min_idx,
      xmax=ref_roi_dt_max_idx,
      ymin=ref_roi_rt_min_idx,
      ymax=ref_roi_rt_max_idx,
      fill = SampleID,
      color = SampleID
    ),
    alpha=0.5
  ) +
  labs(x = "Drift time (index)", "Retention time (index)", title = "Cluster07")
```

Example: Observe that the number of  ROI corresponding cluster 7 equals the number of samples.

- Figures of Merit

The function of `gcims_figures_of_merit()` calculates several of figures of merit of ROI: area, volume, asymmetry and saturation. 
It creates a ".csv" file with all ROI information.

```{r}
peak_list_fom <- gcims_figures_of_merit(
  dir_in = bsln,
  dir_out = fom,
  peak_list = fusion_res$peak_list_clustered,
  cluster_stats = fusion_res$cluster_stats
)
head(peak_list_fom)
```

- Build the peak table: 

You can extract the volume of each sample across samples using the function `build_peak_table()` in the form of a peak table. This will be useful  for in case you want perform machine learning on these data.

```{r}
peak_table <- build_peak_table(peak_list_fom,
                               aggregate_conflicting_peaks = max)
peak_table$peak_table_matrix
```

Note that the peak table obtained present missing values (NA) for clusters 12 and 13, in sample 1.

- Imput Missing Values: 

To input missing values of the peak table, use the function `gcims_missing_imputation()`. It computes the volume in the region of the reference ROI for each cluster for each sample having a missing value for the cluster.
```{r}
peak_table_imputed <- gcims_missing_imputation(
  peak_table = peak_table$peak_table_matrix,
  dir_in = fom,
  cluster_stats = fusion_res$cluster_stats
)
peak_table_imputed
```


# Session Info

```{r}
sessionInfo()
```


