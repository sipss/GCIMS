---
title: "Introduction to GCIMS"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{introduction-to-gcims}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(GCIMS)
```

The GCIMS package allows you to import your Gas Chromatography - Ion Mobility Spectrometry samples,
preprocess them, align them one to each other and build a peak table with the relevant features.

This vignette will use a small dataset consisting of a mixture of three ketones.

## Downloading the dataset:

```{r}
# Download the ketones dataset:
tryCatch({
  download_three_ketones_dataset("threeketones")
}, error = function(e) {
  message("The download of the samples did not succeed. The vignette can't continue.")
  message(conditionMessage(e))
  knitr::knit_exit()
})
```

```{r}
# Check that the files are downloaded:
list.files("threeketones")
```

Enable parallellization of the workflow, here we use three cores:

```{r}
library(BiocParallel)
#register(SerialParam(progressbar = TRUE), default = TRUE)  # disable parallellization
register(SnowParam(workers = 3, progressbar = TRUE), default = TRUE)  # enable parallellization with 3 workers
```


## Create work directories

The first steps, is to create all the directories and folders where the samples are located and will be stored along all the process. 
The current working directory should be the folder where the raw data samples are located. Folders for each pre-processing step will be 
created.

```{r}
wd <- "intermediate_files"
data <- file.path(wd,'data')
reshaped <- file.path(wd,'reshaped')
cut <- file.path(wd,'cut')
interpd <- file.path(wd,'interpd')
filtd <- file.path(wd,'filtd')
bslnd <- file.path(wd,'bslnd')
alignd <- file.path(wd,'alignd')
interpr <- file.path(wd,'interpr')
filtr <- file.path(wd,'filtr')
alignr <- file.path(wd,'alignr')
roispp <- file.path(wd,'roispp')
```

## Import data

Please start by preparing an Excel spreadsheet (or a CSV/TSV file if you prefer)
with your samples and their annotations. Please name the first column `SampleID`
and the second column `Filename`.

```{r}
## We will directly define the data frame here:

sample_annotations <- tibble::tribble(
  ~SampleID, ~Filename,
  "Ketone1", "ketone1.mea",
  "Ketone2", "ketone2.mea",
  "Ketone3", "ketone3.mea",
)
## But you can use the following code:
## Use this for excel spreadsheets:
# sample_annotations <- readxl::read_excel("your_excel_file.xlsx")
## Use this for CSV files:
# sample_annotations <- readr::read_csv("your_csv_file.csv")

sample_annotations
```

Raw data:

- Reading samples: gcims_read_samples
All the samples for the working directory are going to be read and convert into the format needed for working with this package

```{r}
# READING SAMPLES
# For mea or mea.gz files, use:
dataset <- gcims_read_mea(dir_in = "threeketones", dir_out = data)
```

- Reading metadata: gcims_read_metadata
An excel file containing all the metadata information needed is going to be read and all the metadata information will be included 
in the files

```{r}
# READING METADATA
samples <- seq_along(dataset)
#file <- "Metadata.xlsx"
file <- data.frame(
  Name = c(1,2,3),
  OriginalFileName = names(dataset)
)
gcims_read_metadata(dir_in = data, samples, file)
```

- Cut samples: gcims_cut_samples
The samples are cut for a better data manipulation. There are part of the data matrix that does not contain any information.
The sample cut can be performed at the beginning, but also at the end after all the pre-processing.

```{r}
# CUT SAMPLES
rt_range <-c(1, 1300)
dt_range <- c(7, 17)
samples <- 1:15
dir_ir <- data
dir_out <- cut
gcims_cut_samples(dir_in, dir_out, samples, rt_range, dt_range)
```

- Reshape sample: reshape_samples
An adjustment of the dimensions of the samples is performed. There are occasions where the samples do not measure exactly the same,
making very complicated working with them.

```{r}
# RESHAPE SAMPLES
gcims_reshape_samples(dir_in = data, dir_out = reshaped, samples)
```

- Prepare samples: gcims_prepare_data
It does some pre-processing steps such as interpolation, digital filter and decimation.The paramaters needed for each function should be indicated by the user.

```{r}
#PREPARO TODO
dir_in <- cut
dir_out <- prepared
samples <- 1:15
params <-list()
# filtering
params$filter$do <- TRUE
params$filter$order_rt <- 2
params$filter$length_rt <- 19
params$filter$order_dt <- 2
params$filter$length_dt <- 19
# decimation
params$decimate$do <- TRUE
params$decimate$factor_rt <- 2
params$decimate$factor_dt <- 2

gcims_prepare_data(dir_in, dir_out, samples, params)
```

- Create reference: gcims_create_reference
A reference sample is created. This reference sample can be one selected sample, or just the mean of all the samples.

```{r}
# CREATE REFERENCE
dir_in <- prepared
dir_out <- prepared
samples <- 1:15
ref_number <- NULL
gcims_create_reference (dir_in, dir_out, samples, ref_number)
```

- Drift time alignment: align_td

```{r}
#ALIGNMENT DRIFT TIME
dir_in <- prepared
dir_out <- alignd
samples <- 1:15
align_td(dir_in, dir_out,samples)
```

- Visualization 

```{r}
#VISUALIZO
dir_in <- alignd
sample_num <-1
samples <- 1:15
gcims_view_sample(alignd ,sample_num, rt_range = NULL, dt_range = NULL, transform = TRUE)
gcims_plot_spec(alignd, samples, rt_value =NULL, dt_range = c(7.2,10), colorby = "Class")
gcims_plot_chrom(alignd, samples, dt_value =NULL , rt_range =  NULL, colorby = "Class")
```

- Retention time alignment: align_tr
PTW algorithm

```{r}
# Optimization in retention
dir_in <-  alignd
samples <- 1:15
correction_type <- optimize_align_tr(dir_in,  samples)

# ALIGN IN RETENTION TIME
dir_in <-  alignd
dir_out <- alignr
samples <- 1:15
align_tr(dir_in, dir_out, samples, 1)
```


Data Visualization

- Spectra visualziation: gcims_plot_spec

```{r}
# PLOT SPECTRA
rt_value <- NULL
dt_range <- NULL
dir_in <- alignr
gcims_plot_spec(dir_in = alignr, samples, rt_value, dt_range, colorby = "Name")
```

- Chromatograms visualization: gcims_plot_chrom

```{r}
# PLOT CHROMATOGRAMS
dt_value <- NULL
rt_range <- NULL
gcims_plot_chrom(dir_in = alignr, samples, dt_value, rt_range, colorby = "Name")
```

- Sample image visualization: gcims_view_sample

```{r}
# SAMPLE VISUALIZATION
sample_num <- 1
dt_value <- NULL
rt_range <- NULL
gcims_view_sample(dir_in = alignr, sample_num, rt_value, dt_range)
```

Aligned data:

- ROIs detection: gcims_rois_selection


```{r}
# ROIs DETECTION
noise_level <- 3
peak_list <- gcims_rois_selection(dir_in = alignr, dir_out = roispp, samples, noise_level)
head(peak_list)

ggplot() +
  geom_rect(data = peak_list, mapping = aes(xmin=dt_min_idx, xmax=dt_max_idx, ymin=rt_min_idx, ymax=rt_max_idx), color=as.factor(peak_list$SampleID), alpha=0.5)
```

```{r}
peak_clustering <- group_peak_list(peak_list)
```

```{r}
peak_list_clustered <- peak_clustering$peak_list_clustered
```

- ROIs Fusion: gcims_rois_fusion

```{r}
#ROIs Fusion
tt <- gcims_rois_fusion(peak_clustering)
samplestocheck <- tt$peak_list_clustered[which(tt$peak_list_clustered$cluster == 35), ]
ggplot() +
  geom_rect(data = samplestocheck, mapping = aes(xmin=dt_min_idx, xmax=dt_max_idx, ymin=rt_min_idx, ymax=rt_max_idx), color= as.factor(samplestocheck$SampleID), alpha=0.5)
```

```{r}
peak_list_clustered$volume <- 1 # dummy: needs integration
```


```{r}
peak_table <- build_peak_table(peak_list_clustered, mean)
```

```{r}
peak_table$peak_table
```

- Baseline Correction: gcims_remove_baseline

```{r}
dir_in <-  roispp
dir_out <-  bslnr
samples <- c(1:15)
gcims_remove_baseline(dir_in, dir_out, samples, peak_list_clustered)
```

- Figure of Merit: gcims_figures_of_merit
Calculation of the figures of merit: area, volume, asymmetry and saturation.It creates a ".csv" file with all the ROIs information 

```{r}
gcims_figures_of_merit(dir_in = bslnr, dir_out = fom, samples = (1:15))
```

# Session Info:

```{r}
sessionInfo()
```

